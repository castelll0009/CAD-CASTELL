import { extname } from 'node:path';
import { pipe, Effect, Option, flow } from 'effect';
import { loadCollectionFromFS } from '@iconify/utils/lib/loader/fs';
import { getIconData, iconToSVG, parseSVGContent, buildParsedSVG } from '@iconify/utils';
import { pascalize } from '@iconify/utils/lib/misc/strings';
import { importModule } from 'local-pkg';

function resolveOptions(options) {
  const {
    autoInstall = false,
    customCollections = {},
    customize = () => {
    }
  } = options;
  return {
    autoInstall,
    customCollections,
    customize
  };
}

function loadIconFromFS(collection, icon, { autoInstall }) {
  return pipe(
    Effect.promise(async () => {
      const result = await loadCollectionFromFS(collection, autoInstall);
      return Option.fromNullable(result);
    }),
    Effect.map(flow(
      Option.flatMap((iconSet) => Option.fromNullable(getIconData(iconSet, icon))),
      Option.map((i) => iconToSVG(i))
    ))
  );
}

function buildSVG(svg) {
  return pipe(
    Option.fromNullable(parseSVGContent(svg)),
    Option.flatMap((parsed) => Option.fromNullable(buildParsedSVG(parsed)))
  );
}
function loadCustomIcon(collection, icon, options) {
  const custom = options.customCollections[collection];
  if (!custom)
    return Effect.succeed(Option.none());
  if (typeof custom === "function") {
    return Effect.tryPromise(async () => {
      const result = await custom(icon);
      return pipe(
        Option.fromNullable(result),
        Option.flatMap((svg) => buildSVG(svg))
      );
    });
  } else {
    const inline = custom[icon];
    if (!inline)
      return Effect.succeed(Option.none());
    if (typeof inline === "function") {
      return Effect.tryPromise(async () => {
        const result = await inline();
        return pipe(
          Option.fromNullable(result),
          Option.flatMap((svg) => buildSVG(svg))
        );
      });
    }
    return Effect.succeed(buildSVG(inline));
  }
}

function loadIcon(collection, icon, options) {
  return pipe(
    Effect.flatten(loadCustomIcon(collection, icon, options)),
    Effect.orElse(
      () => Effect.flatten(loadIconFromFS(collection, icon, options))
    )
  );
}

const randIdFn = "const __randId = () => Math.random().toString(36).substr(2, 10);";
const idFn = "const __id = (i) => idMap[i];";
function replaceIDs(body, idReplacer, referenceReplacer) {
  const hasID = /="url\(#/.test(body);
  const idMap = {};
  let injectScripts = "";
  if (hasID) {
    body = body.replace(/\b([\w-]+?)="url\(#(.+?)\)"/g, (f, s, id) => {
      idMap[id] = `'${id}':'icons-'+__randId()`;
      return referenceReplacer ? referenceReplacer(f, s, id) : f;
    }).replace(/\bid="(.+?)"/g, (full, id) => {
      if (idMap[id] && idReplacer)
        return idReplacer(full, id);
      return full;
    });
    injectScripts = `${randIdFn}const idMap = {${Object.values(idMap).join(",")}};${idFn}`;
  }
  return {
    svg: body,
    collectedIDs: Object.keys(idMap),
    injectScripts
  };
}

const astroCompiler$1 = {
  async compile({ attributes, body }, { collection, icon }, options) {
    await options.customize(collection, icon, attributes);
    const { injectScripts, svg: handled } = replaceIDs(
      body,
      (_, id) => `id={__id('${id}')}`,
      (_, attr, id) => `${attr}={'url(#'+__id('${id}')+')'}`
    );
    const typeDefs = [];
    const defs = [];
    typeDefs.push("interface Props extends astroHTML.JSX.SVGAttributes {};");
    defs.push(`const defaultAttrs = ${JSON.stringify(attributes)}`);
    defs.push("const props = Astro.props;");
    defs.push("const mergedAttrs = {...defaultAttrs, ...props};");
    const script = ["---", ...typeDefs, ...defs, injectScripts, "---"].join("\n");
    const template = `<svg {...mergedAttrs}>${handled}</svg>`;
    return `${script}
${template}
`;
  }
};

const astroCompiler = {
  async compile({ attributes, body }, { collection, icon }, options) {
    const svgrCore = await importModule("@svgr/core");
    const svgr = svgrCore.transform || (svgrCore.default ? svgrCore.default.transform ?? svgrCore.default : svgrCore.default) || svgrCore;
    await options.customize(collection, icon, attributes);
    const { injectScripts, collectedIDs, svg: handled } = replaceIDs(body);
    const res = await svgr(
      `<svg>${handled}</svg>`,
      {
        plugins: ["@svgr/plugin-jsx"],
        svgProps: attributes,
        replaceAttrValues: collectedIDs.reduce((acc, id) => {
          acc[id] = `{__id('${id}')}`;
          acc[`url(#${id})`] = `{'url(#'+__id('${id}')+')'}`;
          return acc;
        }, {}),
        template: (variables, { tpl }) => {
          return tpl`
          ${variables.imports};

          ${variables.interfaces};

          const ${variables.componentName} = (${variables.props}) => {
            ${injectScripts}
            return ${variables.jsx}
          };
          
          ${variables.exports};
          `;
        }
      },
      { componentName: pascalize(`${collection}-${icon}`) }
    );
    return res;
  }
};

const compilers = {
  ".astro": astroCompiler$1,
  ".jsx": astroCompiler
};

const ICON_MODULE_ID_RE = /virtual:icons(?=\/)/;
async function getViteConfiguration(options) {
  function createPlugin() {
    return {
      name: "astro-icons",
      enforce: "pre",
      resolveId(id) {
        if (ICON_MODULE_ID_RE.test(id)) {
          if (isNormalized(id))
            return id;
          return normalize(id);
        }
      },
      async load(id) {
        if (ICON_MODULE_ID_RE.test(id)) {
          const path = id.replace(ICON_MODULE_ID_RE, "");
          try {
            const program = generateComponentFromPath(path, options);
            const code = await Effect.runPromise(program);
            return {
              code,
              map: { version: 3, mappings: "", sources: [] }
            };
          } catch (err) {
            console.error(err);
          }
        }
      }
    };
  }
  return {
    plugins: [
      createPlugin()
    ]
  };
}
function createIntegration(options = {}) {
  const resolved = resolveOptions(options);
  return {
    name: "astro-icons",
    hooks: {
      "astro:config:setup": async function({ updateConfig }) {
        updateConfig({
          vite: await getViteConfiguration(resolved)
        });
      }
    }
  };
}
function isNormalized(id) {
  return !!extname(id);
}
function normalize(id) {
  const extMap = {
    "?astro": ".astro",
    "?react": ".jsx"
  };
  let ext;
  const queryIndex = id.indexOf("?");
  if (queryIndex > 0)
    ext = extMap[id.slice(queryIndex)];
  ext = ext ?? ".astro";
  return `${queryIndex > 0 ? id.slice(0, queryIndex) : id}${ext}`;
}
function genereteComponent(info, options) {
  const { collection, icon, ext } = info;
  return pipe(
    loadIcon(collection, icon, options),
    Effect.mapError(() => `[astro-icons] Icon \`${collection}/${icon}\` was not found. Is this a typo?`),
    Effect.flatMap((component) => {
      return Effect.promise(async () => {
        const compiler = compilers[ext];
        if (!compiler)
          throw new Error(`[astro-icons] \`${ext}\` is not supported yet.`);
        return await compiler.compile(component, { collection, icon }, options);
      });
    })
  );
}
function generateComponentFromPath(path, options) {
  const extension = extname(path);
  const stripped = path.slice(0, -extension.length);
  const [collection, icon] = stripped.slice(1).split("/");
  if (!(collection && icon))
    return Effect.fail(`[astro-icons] \`${stripped}\` is not a valid icon path!`);
  return genereteComponent({ collection, icon, ext: extension }, options);
}

export { createIntegration as default };
